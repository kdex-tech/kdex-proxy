import { createBrowserHistory as h } from "history";
class i extends HTMLElement {
  appContainerTemplate;
  constructor() {
    super(), this.appContainerTemplate = document.createElement("template"), this.appContainerTemplate.innerHTML = "<slot><em>Application Container (placeholder)</em></slot>";
  }
  static elementName() {
    return "kdex-ui-app-container";
  }
  connectedCallback() {
    this.attachShadow({ mode: "closed" }).appendChild(this.appContainerTemplate.content.cloneNode(!0));
  }
}
customElements.get(i.elementName()) || customElements.define(i.elementName(), i);
class l {
  userState = null;
  callbacks = [];
  getUserState() {
    return this.userState;
  }
  onUserStateChange(t) {
    this.userState && t(this.userState), this.callbacks.push(t);
  }
  setUserState(t) {
    this.userState = t, this.callbacks.forEach((e) => e(t));
  }
  unregisterUserStateChange(t) {
    this.callbacks = this.callbacks.filter((e) => e !== t);
  }
}
const u = new l();
class c {
  pathSeparator;
  loginPath;
  logoutPath;
  loginLabel;
  logoutLabel;
  loginCssQuery;
  logoutCssQuery;
  stateEndpoint;
  constructor() {
    const t = document.querySelector('html head meta[name="kdex-ui"]');
    if (!t)
      throw new Error("kdex-ui meta tag not found");
    this.pathSeparator = t.getAttribute("data-path-separator") || "/_/", this.loginPath = t.getAttribute("data-login-path") || "/~/oauth/login", this.logoutPath = t.getAttribute("data-logout-path") || "/~/oauth/logout", this.loginLabel = t.getAttribute("data-login-label") || "Login", this.logoutLabel = t.getAttribute("data-logout-label") || "Logout", this.loginCssQuery = t.getAttribute("data-login-css-query") || "nav.nav .nav-dropdown a.login", this.logoutCssQuery = t.getAttribute("data-logout-css-query") || "nav.nav .nav-dropdown a.logout", this.stateEndpoint = t.getAttribute("data-state-endpoint") || "/~/state", document.addEventListener("DOMContentLoaded", () => {
      fetch(this.stateEndpoint).then((e) => e.json()).then((e) => {
        u.setUserState(e), this._setLoginLogoutLinks(e);
      });
    });
  }
  _setLoginLogoutLinks(t) {
    if (t.principal) {
      const e = document.querySelector(this.logoutCssQuery);
      e && (e.textContent = this.logoutLabel, e instanceof HTMLAnchorElement ? e.href = this.logoutPath : e.addEventListener("click", () => {
        const a = new URL(window.location.href);
        a.pathname = this.logoutPath, window.location.href = a.toString();
      }));
    } else {
      const e = document.querySelector(this.loginCssQuery);
      e && (e.textContent = this.loginLabel, e instanceof HTMLAnchorElement ? e.href = this.loginPath : e.addEventListener("click", () => {
        const a = new URL(window.location.href);
        a.pathname = this.loginPath, window.location.href = a.toString();
      }));
    }
  }
}
const o = new c();
class r {
  constructor(t) {
    this.config = t, this.host = t.host, this.id = t.id, this.path = t.path;
  }
  host;
  id;
  path;
}
class p {
  items = [];
  callbacks = [];
  history;
  constructor() {
    this.history = h(), this.history.listen(() => {
      this._navigateToAppRoutePath();
    }), document.addEventListener("DOMContentLoaded", this._resetNavigationLinks.bind(this)), document.addEventListener("DOMContentLoaded", this._navigateToAppRoutePath.bind(this));
  }
  _navigateToAppRoutePath() {
    const t = this.currentRoutepath(), e = new Set(this.getItems().map((a) => a.host).filter((a) => a !== void 0));
    for (const a of e)
      t && a.id === t.id ? a.setAttribute("route-path", `/${t.path}`) : a.setAttribute("route-path", "");
  }
  _resetNavigationLinks() {
    for (let t of document.querySelectorAll("a"))
      if (t.href.startsWith(document.location.origin + this.basepath() + o.pathSeparator)) {
        const e = new URL(t.href);
        t.onclick = () => (this.history.push(e.pathname), !1), t.href = "javascript:void(0)";
      }
  }
  addItem(t) {
    this.items.push(t), this.callbacks.forEach((e) => e(this.items));
  }
  basepath() {
    return window.location.pathname.includes(o.pathSeparator) ? window.location.pathname.split(o.pathSeparator, 2)[0] : window.location.pathname.endsWith("/") ? window.location.pathname.slice(0, -1) : window.location.pathname;
  }
  currentRoutepath() {
    if (window.location.pathname.includes(o.pathSeparator)) {
      const t = window.location.pathname.split(o.pathSeparator, 2)[1], [e, a] = t.split("/", 2);
      return new r({
        id: e,
        path: a
      });
    }
    return null;
  }
  findItem(t, e) {
    return this.items.find((a) => a.id === t && a.path === e) || null;
  }
  getItems() {
    return this.items;
  }
  navigate(t) {
    this.history.push(t);
  }
  onItemAdded(t) {
    this.callbacks.push(t);
  }
  registerRoutes(t, ...e) {
    for (const a of e)
      this.addItem(new r({
        host: t,
        id: t.id,
        path: a
      }));
  }
  removeItem(t) {
    this.items = this.items.filter((e) => e !== t), this.callbacks.forEach((e) => e(this.items));
  }
}
const s = new p();
class g extends HTMLElement {
  routePath = null;
  constructor() {
    if (super(), !(this.parentElement instanceof i))
      throw new Error("Parent AppContainerElement not found");
  }
  static get observedAttributes() {
    return ["route-path"];
  }
  attributeChangedCallback(t, e, a) {
    t === "route-path" && (this.routePath = a), this.connectedCallback();
  }
  basepath() {
    return s.basepath();
  }
  connectedCallback() {
  }
  navigate(t) {
    t.startsWith("/") || (t = `/${t}`), s.navigate(`${this.basepath()}${o.pathSeparator}${this.id}${t}`);
  }
  registerRoutes(...t) {
    this.id && s.registerRoutes(this, ...t);
  }
}
export {
  i as AppContainerElement,
  g as AppElement,
  c as AppMeta,
  r as AppRouteItem,
  p as AppRouteRegistry,
  o as appMeta,
  s as appRouteRegistry,
  u as userStateSync
};
//# sourceMappingURL=index.mjs.map
